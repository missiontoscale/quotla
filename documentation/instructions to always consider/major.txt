- Prioritize design for mobile users
- Never push .env or .env.local
- Of all .md files, push only README.md, otherwise, ignore
- Follow OWASP Top 10 guidelines in security principles \OWASP Top 10 2025\
- Always use parameterized queries - never string concatenation for database queries
- Implement proper input validation and sanitization for all user inputs
- Use secure authentication and authorization patterns
- Never hardcode secrets, API keys, or passwords in source code
- Implement proper error handling that doesn't expose sensitive information

## Dependency Management
- Only suggest well-maintained packages with recent updates[if you cannot identofy recent updates, ask me to give you that information by directing me on what to search online]
- Prefer packages with strong security track records
- Flag any dependencies that haven't been updated in 12+ months
- Always check for known vulnerabilities before suggesting packages

## Code Review Requirements
- Generate TODO comments for any code that needs security review
- Add inline comments explaining security-relevant decisions
- Flag any code that handles sensitive data for manual review
- Suggest security test cases for authentication and authorization logic

## Error Handling
- Implement fail-secure patterns (deny by default)
- Log security events appropriately without exposing sensitive data
- Use structured error responses that don't leak implementation details

- Implement transaction isolation and consistency checks
- Follow PCI-DSS requirements for payment data with AES-256 encryption
- Use TLS 1.2+ for all payment data transmission
- Use time-based session management with secure token generation
- Build in rate limiting and fraud detection patterns
- Require multi-factor authentication with FIDO2/WebAuthn standards

- Consider automated security testing that runs as fast as code is generated. Try dynamic application security testing for actual application behavious, not just source code patterns

- Note the following, and learn:
Reviewing AI-generated database code
# BAD - AI might suggest this (vulnerable to SQL injection)
query = f"SELECT * FROM users WHERE id = {user_id}"

# GOOD - Secure parameterized query
query = "SELECT * FROM users WHERE id = %s"
cursor.execute(query, (user_id,))

Note that string interpolation vulnerabilities can occur even when user_id appears safe, particularly when itâ€™s passed from an API without proper validation.

// You might generate functional but insecure code like this:
app.get('/api/user/:id', (req, res) => {
  const user = database.getUser(req.params.id);
  res.json(user);  // Exposes all user data
});

// Secure version with proper authorization and data filtering:
app.get('/api/user/:id', authenticate, (req, res) => {
  if (req.user.id !== req.params.id && !req.user.isAdmin) {
    return res.status(403).json({error: 'Unauthorized'});
  }
  
  const user = database.getUser(req.params.id);
  const safeUser = {
    id: user.id,
    name: user.name,
    // Conditionally return sensitive fields
    email: req.user.isAdmin ? user.email : undefined
  };
  res.json(safeUser);
});

- Look at /design principles as well as /security principles

- Do not create useles .md files, instead keep logs as follows:
PRD [Product Requriements Document updated as work continues]
WhatIsWrong.txt [security and design concerns with percentage scores]
LessonsSoFar.txt [stuff and mistakes that should not be repeated]
README.md [updated as time goes on].

- Prioritize token efficiency. Do not guive useless explanations. Do not read files that should not be read. Use smart algorithms to identify operations with most rewards[in terms of tokens saved] 

- Delete files if they need to be [If replaced, or redundant]

- Always fix references, and make sure all links lead to an actual functional page
