import OpenAI from 'openai'
import { LineItem } from '@/types'
import {
  CHAT_SYSTEM_PROMPT,
  QUOTE_GENERATION_SYSTEM_PROMPT,
  getQuoteGenerationPrompt,
  QUOTE_GENERATION_CONFIG,
  INVOICE_GENERATION_SYSTEM_PROMPT,
  getInvoiceGenerationPrompt,
  INVOICE_GENERATION_CONFIG
} from '@/prompts'

export interface GeneratedQuote {
  client_name: string
  currency?: string
  items: LineItem[]
  subtotal: number
  tax_rate: number
  tax_amount: number
  total: number
  notes?: string
  valid_until?: string
}

export interface GeneratedInvoice {
  client_name: string
  currency?: string
  items: LineItem[]
  subtotal: number
  tax_rate: number
  tax_amount: number
  delivery_charge?: number
  total: number
  notes?: string
  due_date?: string
  invoice_number?: string
  payment_terms?: string
}

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
})

export async function generateDescriptionWithOpenAI(
  prompt: string,
  history?: Array<{role: string, content: string}>
): Promise<string> {
  try {
    // Build messages array with history
    const messages: Array<{role: 'system' | 'user' | 'assistant', content: string}> = [
      {
        role: 'system',
        content: CHAT_SYSTEM_PROMPT,
      }
    ]

    // Add last 5 conversation pairs (10 messages) for context
    if (history && history.length > 0) {
      const recentHistory = history.slice(-10)
      recentHistory.forEach(msg => {
        if (msg.role === 'user' || msg.role === 'assistant') {
          messages.push({
            role: msg.role as 'user' | 'assistant',
            content: msg.content
          })
        }
      })
    }

    // Add current prompt
    messages.push({
      role: 'user',
      content: prompt,
    })

    const completion = await openai.chat.completions.create({
      model: 'gpt-4o-mini',
      messages,
      max_tokens: 200,
      temperature: 0.5,
    })

    const description = completion.choices[0]?.message?.content?.trim()

    if (!description) {
      throw new Error('No description generated')
    }

    return description
  } catch (error) {
    console.error('OpenAI generation error:', error)
    throw new Error('Failed to generate description with OpenAI')
  }
}

export async function generateQuoteWithOpenAI(prompt: string): Promise<GeneratedQuote> {
  // Detect currency from prompt
  const lowerPrompt = prompt.toLowerCase()
  let currency = 'USD'

  if (lowerPrompt.includes('ngn') || lowerPrompt.includes('naira') || lowerPrompt.includes('nigeria')) {
    currency = 'NGN'
  } else if (lowerPrompt.includes('eur') || lowerPrompt.includes('euro')) {
    currency = 'EUR'
  } else if (lowerPrompt.includes('gbp') || lowerPrompt.includes('pound')) {
    currency = 'GBP'
  }

  try {
    const completion = await openai.chat.completions.create({
      model: 'gpt-4o-mini',
      messages: [
        {
          role: 'system',
          content: QUOTE_GENERATION_SYSTEM_PROMPT,
        },
        {
          role: 'user',
          content: getQuoteGenerationPrompt(prompt, currency),
        },
      ],
      max_tokens: QUOTE_GENERATION_CONFIG.maxTokens,
      temperature: QUOTE_GENERATION_CONFIG.temperature,
      response_format: { type: 'json_object' },
    })

    const content = completion.choices[0]?.message?.content?.trim()
    if (!content) {
      throw new Error('No quote generated by AI')
    }

    const quote = JSON.parse(content)

    // Validate and ensure structure
    if (!quote.items || !Array.isArray(quote.items) || quote.items.length === 0) {
      console.error('Invalid quote structure:', quote)
      throw new Error('AI did not generate valid quote items. Please provide more details.')
    }

    // Ensure all items have required fields and add sort_order
    quote.items = quote.items.map((item: any, index: number) => ({
      description: item.description || 'Item',
      quantity: parseFloat(item.quantity) || 1,
      unit_price: parseFloat(item.unit_price) || 0,
      amount: parseFloat(item.amount) || (parseFloat(item.quantity) || 1) * (parseFloat(item.unit_price) || 0),
      sort_order: index,
    }))

    // Validate and ensure numeric fields
    quote.client_name = quote.client_name || 'Client'
    quote.currency = currency
    quote.subtotal = parseFloat(quote.subtotal) || quote.items.reduce((sum: number, item: any) => sum + item.amount, 0)
    quote.tax_rate = parseFloat(quote.tax_rate) || 0.1
    quote.tax_amount = parseFloat(quote.tax_amount) || quote.subtotal * quote.tax_rate
    quote.total = parseFloat(quote.total) || quote.subtotal + quote.tax_amount

    return quote
  } catch (error) {
    console.error('OpenAI quote generation error:', error)
    if (error instanceof Error) {
      if (error.message.includes('JSON') || error.message.includes('parse')) {
        throw new Error('Failed to parse AI response. Please try again with more specific details.')
      }
      throw new Error(error.message)
    }
    throw new Error('Failed to generate quote. Please try again.')
  }
}

export async function generateInvoiceWithOpenAI(prompt: string): Promise<GeneratedInvoice> {
  // Detect currency from prompt
  const lowerPrompt = prompt.toLowerCase()
  let currency = 'USD'

  if (lowerPrompt.includes('ngn') || lowerPrompt.includes('naira') || lowerPrompt.includes('nigeria')) {
    currency = 'NGN'
  } else if (lowerPrompt.includes('eur') || lowerPrompt.includes('euro')) {
    currency = 'EUR'
  } else if (lowerPrompt.includes('gbp') || lowerPrompt.includes('pound')) {
    currency = 'GBP'
  }

  try {
    const completion = await openai.chat.completions.create({
      model: 'gpt-4o-mini',
      messages: [
        {
          role: 'system',
          content: INVOICE_GENERATION_SYSTEM_PROMPT,
        },
        {
          role: 'user',
          content: getInvoiceGenerationPrompt(prompt, currency),
        },
      ],
      max_tokens: INVOICE_GENERATION_CONFIG.maxTokens,
      temperature: INVOICE_GENERATION_CONFIG.temperature,
      response_format: { type: 'json_object' },
    })

    const content = completion.choices[0]?.message?.content?.trim()
    if (!content) {
      throw new Error('No invoice generated by AI')
    }

    const invoice = JSON.parse(content)

    // Validate and ensure structure
    if (!invoice.items || !Array.isArray(invoice.items) || invoice.items.length === 0) {
      console.error('Invalid invoice structure:', invoice)
      throw new Error('AI did not generate valid invoice items. Please provide more details.')
    }

    // Ensure all items have required fields and add sort_order
    invoice.items = invoice.items.map((item: any, index: number) => ({
      description: item.description || 'Item',
      quantity: parseFloat(item.quantity) || 1,
      unit_price: parseFloat(item.unit_price) || 0,
      amount: parseFloat(item.amount) || (parseFloat(item.quantity) || 1) * (parseFloat(item.unit_price) || 0),
      sort_order: index,
    }))

    // Validate and ensure numeric fields
    invoice.client_name = invoice.client_name || 'Client'
    invoice.currency = currency
    invoice.subtotal = parseFloat(invoice.subtotal) || invoice.items.reduce((sum: number, item: any) => sum + item.amount, 0)
    invoice.tax_rate = parseFloat(invoice.tax_rate) || 0.075
    invoice.tax_amount = parseFloat(invoice.tax_amount) || invoice.subtotal * invoice.tax_rate

    // Add delivery charge (3% of subtotal for invoices)
    invoice.delivery_charge = parseFloat(invoice.delivery_charge) || invoice.subtotal * 0.03

    invoice.total = parseFloat(invoice.total) || invoice.subtotal + invoice.tax_amount + (invoice.delivery_charge || 0)

    // Ensure due date is set (30 days from now if not specified)
    if (!invoice.due_date) {
      const dueDate = new Date()
      dueDate.setDate(dueDate.getDate() + 30)
      invoice.due_date = dueDate.toISOString().split('T')[0]
    }

    // Generate invoice number if not present
    if (!invoice.invoice_number) {
      const timestamp = Date.now().toString().slice(-8)
      invoice.invoice_number = `INV-${timestamp}`
    }

    return invoice
  } catch (error) {
    console.error('OpenAI invoice generation error:', error)
    if (error instanceof Error) {
      if (error.message.includes('JSON') || error.message.includes('parse')) {
        throw new Error('Failed to parse AI response. Please try again with more specific details.')
      }
      throw new Error(error.message)
    }
    throw new Error('Failed to generate invoice. Please try again.')
  }
}
